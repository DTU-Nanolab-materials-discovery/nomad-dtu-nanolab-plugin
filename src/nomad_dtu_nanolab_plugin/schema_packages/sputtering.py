#
# Copyright The NOMAD Authors.
#
# This file is part of NOMAD. See https://nomad-lab.eu for further info.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from typing import TYPE_CHECKING

import numpy as np
import plotly.graph_objects as go
from nomad.datamodel.data import ArchiveSection, Schema
from nomad.datamodel.metainfo.annotations import ELNAnnotation, ELNComponentEnum
from nomad.datamodel.metainfo.basesections import (
    CompositeSystem,
    CompositeSystemReference,
    InstrumentReference,
)
from nomad.datamodel.metainfo.plot import PlotlyFigure, PlotSection
from nomad.metainfo import MEnum, Package, Quantity, Section, SubSection
from nomad.units import ureg
from nomad_material_processing.vapor_deposition.general import (
    ChamberEnvironment,
    GasFlow,
)
from nomad_material_processing.vapor_deposition.pvd.general import PVDSource, PVDStep
from nomad_material_processing.vapor_deposition.pvd.sputtering import SputterDeposition
from nomad_measurements.utils import merge_sections

from nomad_dtu_nanolab_plugin.categories import DTUNanolabCategory
from nomad_dtu_nanolab_plugin.schema_packages.gas import DTUGasSupply
from nomad_dtu_nanolab_plugin.sputter_log_reader import (
    plot_plotly_extimeline,
    read_events,
    read_logfile,
)

if TYPE_CHECKING:
    from nomad.datamodel.datamodel import EntryArchive
    from structlog.stdlib import BoundLogger

import os

m_package = Package(name='DTU customised sputter Schemas')


class DTUsamples(CompositeSystemReference, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    relative_position = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    m_def = Section()
    Substrate_position_x = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'cm'},
        unit='m',
    )
    Substrate_position_y = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'cm'},
        unit='m',
    )
    method_of_contact = Quantity(
        type=MEnum(['clamps', 'frame', 'other']),
        default='clamps',
        a_eln={'component': 'RadioEnumEditQuantity'},
    )
    mask_used = Quantity(
        type=bool,
        default=False,
        a_eln=ELNAnnotation(component=ELNComponentEnum.BoolEditQuantity),
    )
    mask_description = Quantity(
        type=str,
        a_eln={'component': 'RichTextEditQuantity'},
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `DTUsamples` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)

        if self.Substrate_position_x is None and self.Substrate_position_y is None:
            if self.relative_position == 'BL':
                self.Substrate_position_x = -0.02
                self.Substrate_position_y = 0.035
            elif self.relative_position == 'BR':
                self.Substrate_position_x = 0.02
                self.Substrate_position_y = 0.035
            elif self.relative_position == 'FL':
                self.Substrate_position_x = -0.02
                self.Substrate_position_y = -0.005
            elif self.relative_position == 'FR':
                self.Substrate_position_x = 0.02
                self.Substrate_position_y = -0.005


class Chamber(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    shutters_open = Quantity(
        type=bool,
        default=False,
        description="""
            Position of the substrate shutter.
        """,
        a_eln=ELNAnnotation(component=ELNComponentEnum.BoolEditQuantity),
    )
    applied_RF_bias_platen = Quantity(
        type=np.float64,
        default=0,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'V'},
        unit='V',
    )
    total_pressure = Quantity(
        type=np.float64,
        default=0.6666,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'mtorr'},
        unit='kg/(m*s^2)',
    )


class Substrate(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    set_point_temperature = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'degC'},
        unit='kelvin',
    )
    corrected_real_temperature = Quantity(
        type=np.float64,
        a_eln={'defaultDisplayUnit': 'degC'},
        unit='kelvin',
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `Substrate` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)
        if self.set_point_temperature is not None:
            # Convert set_point_temperature to 'kelvin' explicitly and get its magnitude
            set_point_temp_in_kelvin = self.set_point_temperature.to('kelvin').magnitude
            # Perform the calculation using the magnitude
            r_temp = (set_point_temp_in_kelvin * 0.905) + 12
            # Assign the result back to, ensuring it's a Quantity with 'kelvin' unit
            self.corrected_real_temperature = r_temp * self.set_point_temperature.u


class SCracker(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    Zone1_temperature = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'degC'},
        unit='kelvin',
    )
    Zone2_temperature = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'degC'},
        unit='kelvin',
    )
    Zone3_temperature = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'degC'},
        unit='kelvin',
    )
    valve_ON_time = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 's'},
        unit='s',
    )
    valve_frequency = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'Hz'},
        unit='1/s',
    )
    S_partial_pressure = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'mbar'},
        unit='kg/(m*s^2)',
    )


class Special(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    platen_temperature_ramp_rate = Quantity(
        type=np.float64,
        default=0.3333,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'degC/minute'},
        unit='kelvin/s',
    )
    target_ramp_rate = Quantity(
        type=np.float64,
        default=1,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'W/second'},
        unit='(kg*m^2)/s^4',
    )
    active_targets = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    active_gases = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    total_deposition_rate = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'angstrom/s'},
        unit='m/s',
    )


class DTUsputter_parameters(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    chamber = SubSection(
        section_def=Chamber,
    )
    substrate = SubSection(
        section_def=Substrate,
    )
    S_cracker = SubSection(
        section_def=SCracker,
    )
    special = SubSection(
        section_def=Special,
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `DTUsputter_parameters` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


class DTUsource(PVDSource, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    source_shutter_open = Quantity(
        type=bool,
        default=False,
        a_eln=ELNAnnotation(component=ELNComponentEnum.BoolEditQuantity),
    )

    power_type = Quantity(
        type=MEnum(['RF', 'DC', 'pulsed_DC']),
        default='RF',
        a_eln={'component': 'RadioEnumEditQuantity'},
    )
    applied_voltage = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'V'},
        unit='V',
    )
    applied_power = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'W'},
        unit='(kg*m^2)/s^3',
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `DTUsource` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


class DTUGasFlow(GasFlow, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    gas_supply = Quantity(
        type=DTUGasSupply,
    )
    gas_name = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    used_gas_supply = Quantity(
        type=CompositeSystem,
        a_eln=ELNAnnotation(component=ELNComponentEnum.ReferenceEditQuantity),
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `DTUGasFlow` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)
        self.gas_name = self.used_gas_supply.name
        self.gas.name = self.used_gas_supply.name
        self.gas.iupac_name = self.used_gas_supply.iupac_name
        self.gas.molecular_formula = self.used_gas_supply.molecular_formula
        self.gas.molecular_mass = self.used_gas_supply.molecular_mass
        self.gas.inchi = self.used_gas_supply.inchi
        self.gas.inchi_key = self.used_gas_supply.inchi_key
        self.gas.smile = self.used_gas_supply.smiles
        self.gas.canonical_smile = self.used_gas_supply.canonical_smiles
        self.gas.cas_number = self.used_gas_supply.cas_number


class DTUChamberEnvironment(ChamberEnvironment, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    gas_flow = SubSection(
        section_def=DTUGasFlow,
        repeats=True,
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `DTUChamberEnvironment` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


class DTUsteps(PVDStep, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    sources = SubSection(
        section_def=DTUsource,
        repeats=True,
    )
    sputter_parameters = SubSection(
        section_def=DTUsputter_parameters,
        repeats=True,
    )
    environment = SubSection(
        section_def=DTUChamberEnvironment,
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `DTUsteps` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


class EndOfProcess(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    taken_out = Quantity(
        type=MEnum(['front', 'back']),
        default='front',
        a_eln={'component': 'RadioEnumEditQuantity'},
    )
    Heater_temperature = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'degC'},
        unit='kelvin',
    )
    time_in_chamber_after_ending_deposition = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'minute'},
        unit='s',
    )
    chamber_purged = Quantity(
        type=bool,
        default=False,
        a_eln=ELNAnnotation(component=ELNComponentEnum.BoolEditQuantity),
    )


class AdjustedInstrumentParameters(InstrumentReference, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    platen_rotation = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'degree'},
        unit='rad',
    )
    stage_used = Quantity(
        type=MEnum(['heating', 'cooling']),
        default='heating',
        a_eln={'component': 'RadioEnumEditQuantity'},
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `AdjustedInstrumentParameters` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)
        self.lab_id = self.reference.lab_id
        self.name = self.reference.name


class GunOverview(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    target_material = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    applied_power = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'W'},
        unit='(kg*m^2)/s^3',
    )
    plasma_ignited_at = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'W'},
        unit='(kg*m^2)/s^3',
    )
    power_type = Quantity(
        type=MEnum(['DC', 'RF', 'pulsed_DC']),
        default='RF',
        a_eln={'component': 'RadioEnumEditQuantity'},
    )
    stable_average_voltage = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'V'},
        unit='V',
    )
    comments_about_voltage = Quantity(
        type=str,
        a_eln={'component': 'RichTextEditQuantity'},
    )


class UsedGas(GasFlow, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    gas_name = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    used_gas_supply = Quantity(
        type=CompositeSystem,
        a_eln=ELNAnnotation(component=ELNComponentEnum.ReferenceEditQuantity),
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `UsedGas` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)
        self.gas_name = self.used_gas_supply.name
        self.gas.name = self.used_gas_supply.name
        self.gas.iupac_name = self.used_gas_supply.iupac_name
        self.gas.molecular_formula = self.used_gas_supply.molecular_formula
        self.gas.molecular_mass = self.used_gas_supply.molecular_mass
        self.gas.inchi = self.used_gas_supply.inchi
        self.gas.inchi_key = self.used_gas_supply.inchi_key
        self.gas.smile = self.used_gas_supply.smiles
        self.gas.canonical_smile = self.used_gas_supply.canonical_smiles
        self.gas.cas_number = self.used_gas_supply.cas_number


class DepositionParameters(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    deposition_temperature = Quantity(
        type=np.float64,
        default=300,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'degC'},
        unit='kelvin',
    )
    deposition_time = Quantity(
        type=np.float64,
        default=1800,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'minute'},
        unit='s',
    )
    sputter_pressure = Quantity(
        type=np.float64,
        default=0.6666,
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'mtorr'},
        unit='kg/(m*s^2)',
    )
    material_space = Quantity(
        type=str,
        default='-P-S',
        a_eln={'component': 'StringEditQuantity'},
    )
    ar_flow = Quantity(
        type=np.float64,
        a_eln={
            'component': 'NumberEditQuantity',
            'defaultDisplayUnit': 'cm^3/minute',
            'label': 'Ar flow',
        },
        unit='m^3/s',
    )
    ar_partial_pressure = Quantity(
        type=np.float64,
        a_eln={
            'defaultDisplayUnit': 'mtorr',
            'label': 'Ar partial pressure',
        },
        unit='kg/(m*s^2)',
    )
    h2s_in_Ar_flow = Quantity(
        type=np.float64,
        description="""
            Flow of 10% H2S in Ar in equivalent flow at standard conditions 0, i.e.
            the equivalent rate at a temperature of 0 °C (273.15 K) and a pressure of
            1 atm (101325 Pa).
        """,
        a_eln={
            'component': 'NumberEditQuantity',
            'defaultDisplayUnit': 'cm^3/minute',
            'label': 'H2S in Ar flow',
        },
        unit='m^3/s',
    )
    h2s_partial_pressure = Quantity(
        type=np.float64,
        a_eln={
            'defaultDisplayUnit': 'mtorr',
            'label': 'H2S partial pressure',
        },
        unit='kg/(m*s^2)',
    )
    ph3_in_Ar_flow = Quantity(
        type=np.float64,
        description="""
            Flow of 10% PH3 in Ar in equivalent flow at standard conditions 0, i.e.
            the equivalent rate at a temperature of 0 °C (273.15 K) and a pressure of
            1 atm (101325 Pa).
        """,
        a_eln={
            'component': 'NumberEditQuantity',
            'defaultDisplayUnit': 'cm^3/minute',
            'label': 'PH3 in Ar flow',
        },
        unit='m^3/s',
    )
    ph3_partial_pressure = Quantity(
        type=np.float64,
        a_eln={
            'defaultDisplayUnit': 'mtorr',
            'label': 'PH3 partial pressure',
        },
        unit='kg/(m*s^2)',
    )
    target_image_before = Quantity(
        type=str,
        a_eln={
            'component': 'FileEditQuantity',
            'label': 'Image of target before the deposition',
        },
    )
    target_image_after = Quantity(
        type=str,
        a_eln={
            'component': 'FileEditQuantity',
            'label': 'Image of target after the deposition',
        },
    )
    heating_procedure_description = Quantity(
        type=str,
        a_eln={'component': 'RichTextEditQuantity'},
    )
    cooling_procedure_description = Quantity(
        type=str,
        a_eln={'component': 'RichTextEditQuantity'},
    )
    Magkeeper3 = SubSection(
        section_def=GunOverview,
    )
    Magkeeper4 = SubSection(
        section_def=GunOverview,
    )
    Taurus = SubSection(
        section_def=GunOverview,
    )
    SCracker = SubSection(
        section_def=SCracker,
    )
    used_gases = SubSection(
        section_def=UsedGas,
        repeats=True,
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `DepositionParameters` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """

        super().normalize(archive, logger)
        # derived quantities
        # partial pressures without the S-cracker taken into account
        p_ok = False
        if self.ar_flow is not None:
            flow = self.ar_flow.magnitude
            ar = self.ar_flow.magnitude
            if self.h2s_in_Ar_flow is not None:
                flow += self.h2s_in_Ar_flow.magnitude
                h2s = self.h2s_in_Ar_flow.magnitude
                if self.ph3_in_Ar_flow is not None:
                    flow += self.ph3_in_Ar_flow.magnitude
                    ph3 = self.ph3_in_Ar_flow.magnitude
                    p_ok = True

        if self.sputter_pressure is not None and p_ok:
            p = self.sputter_pressure.to('kg/(m*s^2)').magnitude
            total_ar = ar / flow * p + h2s * 0.9 / flow * p + ph3 * 0.9 / flow * p
            self.ar_partial_pressure = total_ar * self.sputter_pressure.u
            self.h2s_partial_pressure = h2s * 0.1 / flow * p * self.sputter_pressure.u
            self.ph3_partial_pressure = ph3 * 0.1 / flow * p * self.sputter_pressure.u


class DTUSputtering(SputterDeposition, PlotSection, Schema):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        categories=[DTUNanolabCategory],
        label='Sputtering',
    )
    lab_id = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity', 'label': 'Run ID'},
    )
    location = Quantity(
        type=str,
        default='DTU; IDOL Lab',
        a_eln={'component': 'StringEditQuantity'},
    )
    log_file = Quantity(
        type=str,
        a_eln={'component': 'FileEditQuantity', 'label': 'Log file'},
    )
    samples = SubSection(
        section_def=DTUsamples,
        repeats=True,
    )
    steps = SubSection(
        section_def=DTUsteps,
        repeats=True,
    )
    end_of_process = SubSection(
        section_def=EndOfProcess,
    )
    instruments = SubSection(
        section_def=AdjustedInstrumentParameters,
        repeats=True,
    )
    deposition_parameters = SubSection(
        section_def=DepositionParameters,
    )

    def plot(self, events_plot, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        fig = go.Figure()

        #Making the plot from the plot_plotly_extimeline function
        fig = plot_plotly_extimeline(events_plot)

        # Update layout
        # fig.update_layout('Colormap',
        #     xaxis_title='X label',
        #     yaxis_title='Y label',
        #     template='plotly_white',
        #     hovermode='closest',
        #     dragmode='zoom',
        # )

        plot_json = fig.to_plotly_json()
        plot_json['config'] = dict(
            scrollZoom=False,
        )
        self.figures.append(
            PlotlyFigure(
                label='Process timeline',
                figure=plot_json,
            )
        )

    def write_log_data(
        self, params: dict, archive: 'EntryArchive', logger: 'BoundLogger'
    ) -> None:
        """
        Method for writing the log data to the respective sections.

        Args:
            params (dict): Dictionary containing the log data.
            archive (EntryArchive): The archive containing the section that
              is being written.
            logger (BoundLogger): A structlog logger.
        """
        #Helper method to write the data

        time_units = ['second', 'minute', 'hour']

        def write_sputtering_data(input_dict: dict, input_keys: list,
                                    sputtering, output_attr: str, unit: str):
                try:
                    value = get_nested_value(input_dict, input_keys)
                    if value is None:
                        raise ValueError(f"Missing value for keys: {input_keys}")

                    if unit in time_units:
                        setattr(sputtering, output_attr,
                        ureg.Quantity(value.total_seconds(), unit))
                    elif unit:
                        setattr(sputtering, output_attr, ureg.Quantity(value, unit))
                    else:
                        setattr(sputtering, output_attr, value)

                except Exception as e:
                    input_path = 'params'
                    for key in input_keys:
                        input_path += f'[\'{key}\']'
                    logger.warning(
                        f'Failed writing {input_path} to \
                        sputtering.{output_attr}: {str(e)}'
                    )


        #Helper method to get the nested value, if it exists
        def get_nested_value(dictionary, key_path):
            """
            Safely get a nested value from a dictionary.

            :param dictionary: The dictionary to traverse.
            :param key_path: A list of keys representing the path
                to the desired value.
            :return: The value at the end of the key path, or None if not found.
            """
            for key in key_path:
                if isinstance(dictionary, dict):
                    dictionary = dictionary.get(key)
                else:
                    return None
            return dictionary


        #Definiting the input, ouput and unit
        data = [
            [['deposition','avg_temp_1'],
            'deposition_parameters.deposition_temperature','degC'],

            [['deposition','duration'],
            'deposition_parameters.deposition_time','second'],

            [['deposition','avg_capman_pressure'],
            'deposition_parameters.sputter_pressure','mtorr'],

            [['deposition','material_space'],
            'deposition_parameters.material_space', None],
        ]

        # Initializing a temporary DTUSputtering object
        sputtering = DTUSputtering()
        # Initializing the deposition parameters
        sputtering.deposition_parameters = DepositionParameters()

        # Looping through the data
        for input_keys, output_val, unit in data:

            try:
                write_sputtering_data(params, input_keys, output_val, unit)
                # logger.warning(
                #     f'{params} {input_keys} {output_val}')
            except Exception:
                input_path = 'params'
                for key in input_keys:
                    input_path += f'[\'{key}\']'
                logger.warning(
                    f'Failed writing {input_path} to sputtering.{output_val}')
        # # Initializing a temporary DTUSputtering object as
        # sputtering = DTUSputtering()

        # #Initializing the deposition parameters
        # sputtering.deposition_parameters = DepositionParameters()

        # #Get the deposition sub dictionary
        # deposition = params.get('deposition', {})

        # sputtering.deposition_parameters.deposition_temperature = ureg.Quantity(
        #     deposition['avg_temp_1'], 'degC'
        # )

        # sputtering.deposition_parameters.deposition_time = ureg.Quantity(
        #     deposition['duration'].total_seconds(), 'second'
        # )

        # sputtering.deposition_parameters.sputter_pressure = ureg.Quantity(
        #     deposition['avg_capman_pressure'], 'mtorr'
        # )

        # sputtering.deposition_parameters.material_space = deposition['material_space']

        # Getting the deposition sub-dictionary
        deposition = params.get('deposition', {})

        #Special case for the adjusted instrument parameters
        instrument_reference = AdjustedInstrumentParameters()
        if 'platen_position' in deposition:
            instrument_reference.platen_rotation = ureg.Quantity(
                deposition['platen_position'], 'degree'
            )
        sputtering.instruments = [instrument_reference]

        # Merging the sputtering object with self
        merge_sections(self, sputtering, logger)

        # Overwriting the datetime and end_time
        self.datetime = params['overview']['log_start_time']

        self.end_time = params['overview']['log_end_time']

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `DTUSputtering` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """

        super().normalize(archive, logger)

        # sample_number = len(self.samples)
        # j = 0
        # for j in range(sample_number):
        #    sample_name = str(self.name) + '_' + str(self.samples[j].relative_position)
        #    self.samples[j].name = sample_name
        #    self.samples[j].lab_id = sample_name

        if self.log_file:

            # Extracting the sample name from the log file name
            log_name = os.path.basename(self.log_file)
            sample_id = '_'.join(log_name.split('.')[0:2])
            # If lab_id is empty, assign the sample name to lab_id
            if self.lab_id is None:
                self.lab_id = sample_id

            with archive.m_context.raw_file(self.log_file, 'r') as log:
                log_df = read_logfile(log.name)
                events_plot, params, _ = read_events(log_df)

            if params is not None:
                self.write_log_data(params, archive, logger)

            # self.figures = []
            # if events_plot is not None:
            #     self.plot(events_plot, archive, logger)

            # to automate the take over of te references
            # for the further processing see in the respective sections
            # if gas flow of whatever gas is not 0
            #   self.steps.environment.gas_flow.gas_name =
            #   self.depositsition_parameters.used_gas.gas_name
            #   self.steps.environment.gas_flow.used_gas_supply =
            #   self.depositsition_parameters.used_gas.used_gas_supply

        # ToDos:
        # next test to autofill all lab_id fields from their respective references


m_package.__init_metainfo__()
