#
# Copyright The NOMAD Authors.
#
# This file is part of NOMAD. See https://nomad-lab.eu for further info.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import os
from typing import TYPE_CHECKING

import numpy as np
#i have opinions
import pandas as pd
from nomad.atomutils import Formula
from nomad.datamodel.data import Schema
from nomad.datamodel.metainfo.annotations import (
    BrowserAnnotation,
    ELNAnnotation,
    ELNComponentEnum,
    Filter,
    SectionProperties,
)
from nomad.datamodel.metainfo.basesections import (
    CompositeSystem,
    PureSubstanceComponent,
    PureSubstanceSection,
)
from nomad.datamodel.results import Material, Results
from nomad.metainfo import (
    Datetime,
    Package,
    Quantity,
    Section,
    SubSection,
)

from nomad_dtu_nanolab_plugin.categories import DTUNanolabCategory

if TYPE_CHECKING:
    from nomad.datamodel.datamodel import EntryArchive
    from structlog.stdlib import BoundLogger

m_package = Package(name='DTU customised Target scheme')


FILE_NAME = {
    'nomad': 0,
    'ready': 1,
    'chemical_formula': 2,
    'supplier': 3,
    'number': 4,
}
UNIT_FACTORS = {
    'wt%': 1e-2,
    'ppm': 1e-6,
    'ppb': 1e-9,
    'ppt': 1e-12,
}


class DTUTarget(CompositeSystem, Schema):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        categories=[DTUNanolabCategory],
        label='Target',
        a_eln=ELNAnnotation(
            properties=SectionProperties(
                visible=Filter(
                    exclude=[
                        'components',
                    ],
                ),
                order=[
                    'name',
                    'lab_id',
                    'main_material',
                    'supplier_id',
                    'purity',
                    'impurity_file',
                    'thickness',
                    'magkeeper_target',
                    'datetime',
                    'refill_or_mounting_date',
                    'time_used',
                    'description',
                    'main_phases',
                    'impurities',
                    'composition',
                ],
            )
        ),
    )
    main_material = Quantity(
        type=str,
        description="""
        The main material of the target.
        """,
        a_eln=ELNAnnotation(component=ELNComponentEnum.StringEditQuantity),
    )
    # main_elements = Quantity(
    #     type=MEnum(chemical_symbols[1:]),
    #     shape=['*'],
    #     description="""
    #     The symbol of the element, e.g. 'Pb'.
    #     """,
    #     a_eln=dict(component='AutocompleteEditQuantity'),
    # )
    supplier_id = Quantity(
        type=str,
        a_eln=ELNAnnotation(component=ELNComponentEnum.StringEditQuantity),
    )
    target_number = Quantity(
        type=int,
        description='The target number.',
        a_eln=ELNAnnotation(component=ELNComponentEnum.NumberEditQuantity),
    )
    purity = Quantity(
        type=np.float64,
        a_eln=ELNAnnotation(component=ELNComponentEnum.NumberEditQuantity),
    )
    impurity_file = Quantity(
        type=str,
        a_browser=BrowserAnnotation(adaptor='RawFileAdaptor'),
        description="""
        Upload a text file specifying the impurities here.
        File has to be created with a separate code.
        """,
        a_eln=ELNAnnotation(component=ELNComponentEnum.FileEditQuantity),
    )
    thickness = Quantity(
        type=np.float64,
        default=0.00635,
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.NumberEditQuantity,
            defaultDisplayUnit='mm',
        ),
        unit='m',
    )
    magkeeper_target = Quantity(
        type=bool,
        default=True,
        a_eln=ELNAnnotation(component=ELNComponentEnum.BoolEditQuantity),
    )
    refill_or_mounting_date = Quantity(
        type=Datetime,
        a_eln=ELNAnnotation(component=ELNComponentEnum.DateEditQuantity),
    )
    time_used = Quantity(
        type=np.float64,
        description='The time the target or cracker has been used in the system',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.NumberEditQuantity,
            defaultDisplayUnit='minute',
        ),
        unit='s',
    )
    datetime = Quantity(
        type=Datetime,
        description='The delivery date of the target.',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.DateEditQuantity,
            label='Delivery date',
        ),
    )
    main_phases = SubSection(
        section_def=PureSubstanceComponent,
        repeats=True,
    )
    impurities = SubSection(
        section_def=PureSubstanceComponent,
        repeats=True,
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `DTUTargets` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        if self.impurity_file is None:
            return super().normalize(archive, logger)

        file_name: str = os.path.basename(self.impurity_file)
        file_info_list = os.path.splitext(file_name)[0].split('_')
        if len(file_info_list) != len(FILE_NAME):
            logger.warning('The file name does not follow the correct format')
            return super().normalize(archive, logger)
        info = {key: value for key, value in zip(FILE_NAME.keys(), file_info_list)}
        self.lab_id = f'{info["chemical_formula"]}_{info["supplier"]}_{info["number"]}'

        if info['supplier'] == 'T':
            self.supplier_id = 'Testbourne'
        elif info['supplier'] == 'L':
            self.supplier_id = 'Lesker'
        self.main_material = info['chemical_formula']
        self.target_number = int(info['number'])

        pure_substance = PureSubstanceSection(
            molecular_formula=self.main_material,
        )
        self.main_phases = [
            PureSubstanceComponent(
                name='Main component: ' + self.main_material,
                pure_substance=pure_substance,
            )
        ]

        with archive.m_context.raw_file(self.impurity_file, 'r') as impurity:
            df_data: pd.DataFrame = pd.read_csv(
                impurity,
                delimiter=' ',
                header=None,
                names=['symbol', 'mass_fraction', 'unit'],
            )

        df_data = df_data.replace({'<': ''}, regex=True)

        impurities: list[PureSubstanceComponent] = []
        for _, row in df_data.iterrows():
            component = PureSubstanceComponent()
            component.name = 'Impurity component: ' + row['symbol']
            component.pure_substance = PureSubstanceSection(
                molecular_formula=row['symbol'],
            )
            if factor := UNIT_FACTORS.get(row['unit']):
                component.mass_fraction = float(row['mass_fraction']) * factor
            else:
                logger.warning(f'The impurity unit "{row["unit"]}" is not a valid unit')
                continue
            impurities.append(component)

        self.impurities = impurities
        self.components = self.main_phases + self.impurities

        super().normalize(archive, logger)

        if self.purity is None and self.impurities:
            impurities = sum([impurity.mass_fraction for impurity in self.impurities])
            self.purity = 100 * (1 - impurities)
        if archive.results is None:
            archive.results = Results()
        if archive.results.material is None:
            archive.results.material = Material()
        archive.results.material.elements = Formula(self.main_material).elements()


m_package.__init_metainfo__()
